# Dart Fundamental

## 01. Introduction to Dart Fundamental
We have learned how to create a simple “Hello, World!” application. using Darts. In this module we will learn the basic concepts of Darts. Some of the topics we will study include *variables, data types, operators, and functions*.

&emsp;
## 02. Comments
Before starting to develop more complex applications, there is one more important thing we need to know, namely instructions to the computer to ignore parts of a program. Code written in a program but not executed by a computer is called "comments."

A comment will be passed during the compilation process, so it will not affect the flow of the program we write. Comments can be used as documentation that explains the code that we write. 
There are three types of comments that can be used on Dart. 

**The first** is a single-line comment or one-line comment that begins with a `//` sign and ends at the end of that line.

```dart
// Single line comment
```

**The second** is a multi-line comment where we can write several lines of comments. This comment starts with `/* and ends with */`.

```dart
/*
  multi
  line
  comment
*/
```

**The last** is the documentation comment. This comment is a single-line comment or multi-line comment that begins with `/// or /**`.

In the documentation comment, the Dart compiler will ignore all text except those enclosed in square brackets `[ ]`. Inside the square brackets we can enter a reference from the name of a class, variable, or function. The following is an example of using comments:

```dart
import 'package:Learn_Dart/Learn_Dart.dart' as Learn_Dart;

/// The [main] function will display 2 outputs
/// The first output displays text and the second output displays the multiplication results in the [Learn_Dart] library
void main(List<String> arguments) {
  // Create "Hello Darts! Darts are great." on console
  print('Hello Dart! Dart is great.');
  // Testing documentation comment with [].
  print('6 * 7 = ${Learn_Dart.calculate()}');
}

/*
  output:
    Hello Dart! Dart is great.
    6 * 7 = 42
 */
```

If you use the IDE and then press **Ctrl** and hover over the text in square brackets, then you will be able to click and navigate to the reference code. It is good practice to write comments on code. But note, "Good code has a lot of comments, while bad code requires a lot of comments."

&emsp;
## 03. Variables
When we write a program, we tell the computer how to process information such as printing text to a screen or performing computational operations. To make it easier to use and call this data, we can use variables. A variable can be thought of as a box or container that stores values. In the computer this variable is stored in the computer's memory. Each variable has a name that we can call and use.

In Dart we define a variable with the `var keyword`.

```dart
var greetings = 'Hello Dart!';
```

Notice the equal sign (=) above. This symbol is known as the **assignment operator**. The above code means that we enter the value of 'Hello Dart!' into a box or variable named greetings. The process of assigning values ​​to these variables is called initialization.

Next let's try to output the value of this variable to the console. Change your main function code to something like this:

```dart
void main() {
  var greetings = 'Hello Dart!';
  print(greetings);
}
```

In the code example above we enter data in the form of text into a variable. Then, what about numeric data or in the form of numbers? Of course, I can. You can simply initialize the variable with a numeric value.

```dart
var myAge = 20;
print(myAge);
```

So what if we want to create a variable but don't want to initialize it right away? Say you want to wait for some operation to finish then initialize it into a variable.

This process is called variable declaration. The variable declaration will store the name and space in memory without assigning a value. You can initialize the value after declaration according to your requirement.

```dart
var myAge;
myAge = 20;
print(myAge);
```

Now try to comment the variable initialization code above and run the program, what happens?

Is your console displaying null? Each variable declaration will return a default value of null. This means that the variable has not been initialized or you could say that your variable has no value or is null.

&emsp;
## 04. Data Types
In the previous material we have learned about variables that can store values. So how do computers distinguish between a variable that is a number or a text value? And why is it important to be able to tell the difference?

Darts has many data types that represent the types of data we can use and how they are operated. With data types, computers can avoid operations that are impossible and can generate bugs, such as multiplying alphabetic characters or converting numbers to capitals.

Dart is a language that supports type `inference`. When you declare a variable with `var`, Dart will automatically determine its data type. For example :

```dart
var greetings = 'Hello Dart!';  // String
var myAge = 20;                 // integers
```

The computer will know that the `greetings` variable has a `String` or text value and the `myAge` variable has a `number or integer` value even if we don't explicitly define it.

You can still declare variable data types explicitly to avoid confusion and make *debugging* easier.

```dart
String greetings = 'Hello Dart!';
int myAge = 20;
```

Some of the data types supported by Dart include:
<br>
|No   |Type       | Desc                |Example                  |
|-----|-----------|---------------------|-------------------------|
|1.   |int        |Integer              |5, -7, 0                 |
|2.   |double     |Decimals             |3.14, 18.0, -12.12       |
|3.   |num        |Integers & decimal   |5, 3.14, -12.12          |
|4.   |bool       |Boolean              |true, false              |
|5.   |String     |Text                 |'me', ' ', ''            |
|6.   |List       |Data List            |[1, 2, 3], ['a','b','c'] |
|7.   |Map        |Key-value pairs      |{“x”: 4, “y”: 10}        |
|8.   |dynamic    |all data type        |                         |

Dart supports type *inference*, interestingly when we declare a variable without initializing it, the variable will have a **dynamic** type. Since a variable with *dynamic* value can contain any type, there is no problem if we change the value in it.

```dart
var x;  // dynamic
x = 7;
x = 'Dart is great';
print(x);
```

The code above can still run and display the message 'Dart is great' without any problems. It's different if we initialize the value of the variable `x` directly. As a result, the editor will display an error due to a data type change.

```dart
var x = 7;  // int
x = 'Dart is great'; // error assignment
print(x);
```

### Accept user input
In addition to displaying messages to the console, we can also receive user input for further processing and display. This allows us to create applications that are interactive with the user.

To be able to accept input, we will use the statement `stdin.readLineSync()`. This function is part of the `dart:io` library, so we need to import the library.

```dart
import 'dart:io';
```

This time we're going to create a simple app that accepts name and age input from the user and then displays a message to the console. Before looking at the solution code below can you translate the following *flowchart* into application code?

<p align="center" width="100%">
  <img src="https://github.com/DVCone/flutter_course/blob/main/assets/03_a.jpeg" alt="alternate text">
</p>

### Solution
In the above problem we need to display the output, accept some input, and display the output again according to the given input. The code you need to write is more or less like this:

```dart
import 'dart:io';
 
void main() {
  stdout.write('Your Name : ');
  String name = stdin.readLineSync()!;
  stdout.write('Your Age : ');
  int age = int.parse(stdin.readLineSync()!);
  print('Halo $name, Your Age is $age years old');
}
```

If your code is different because it uses `print()` then no problem. The `print()` and `stdout.write()` statements have the same function, which is to output an object to the console. The difference is that `print()` will print a new line after displaying something so next you need to enter the input on a new line. While `stdout.write()` only displays the object and when there is new input or output it will still be displayed on the same line.

In addition, we add the `!` after `stdin.readLineSync()` to indicate that the input will not return a `null` value. We will discuss the explanation regarding the null value in more detail later in the null safety material.

Another new code is `int.parse()`. We use this code to convert `String` data type to `int`. The input taken from `stdin.readLineSync()` will have a `String` data type. So when we want to store and operate input in other data types we need to do the conversion first.

&emsp;
## 05. Numbers
Numeric data types on Darts can be stored in two types: `int` and `double`.

*Integers* value are ​​not bigger than 64 bits depending on the platform used. For Dart VM *integer* variables can store values ​​ranging from -2^63 to 2^63 - 1, while compiled to JavaScript *integers* have values ​​from -2^53 to 2^53 - 1. An *integer* is a number that does not have a decimal point. Examples are as follows:

```dart
var number = 2020;
var hex = 0xDEADBEEF;
```

If a number is a decimal number, then the number is a `double` data type. `Double` also has a size of 64 bits. The following is an example of a `double` variable:

```dart
double withoutDecimal = 7; 
// is same as 
double withoutDecimal = 7.0;
```

*Int* and *double* are subtypes of the *num* data type. We can use these three data types to perform basic calculations such as addition, multiplication, to use functions such as `abs(), ceil(), floor(),` and many other functions. If you need calculation operations but they are not available on these three data types then you can take advantage of the `dart:math` library.

In the previous material we had a need to convert type `String` to `int`. This data type conversion is important and we will need it a lot. In addition to converting `String` to `int`, we can also convert double to String or vice versa.

```dart
// String -> int
var eleven = int.parse('11');

// String -> double
var elevenPointTwo = double.parse('11.2');
  
// int -> String
var elevenAsString = 11.toString();
  
// double -> String
var piAsString = 3.14159.toStringAsFixed(2); // String piAsString = '3.14'
```

&emsp;
## 06. Strings
We have used String a lot in previous materials and as we know, String is used to store data in text form. Strings in Darts can be defined using either single or double quotes.

```dart
String singleQuote = 'This is String';
String doubleQuote = "This is also String";
```

You can use quotation marks interchangeably, especially if you have text that contains quotation marks.

```dart
print('"What do you think of Dart?" he asked');
```

So what if our text has these two quotes?

```dart
print('"I think it's great!" I answered confidently');
```

Of course the above code will produce an error. The solution, use a backslash `\` to reduce ambiguity in quotation marks. This mechanism is also known as the **escape string**. So the code above will be like this:

```dart
print('"I think it\'s great!" I answered confidently');
```

A *backslash* before these quotes will tell Dart that they are just quotes and should not be construed as string delimiters. In addition to quotation marks, backslashes are also useful for ignoring other ambiguous symbols in a string, such as the backslash itself.

```dart
print("Windows path: C:\\Program Files\\Dart");
```

Another feature of String is **String interpolation** where we can enter the value of a variable or expression into a string. We can apply this interpolation with the `$` symbol.

```dart
var name = 'John';
print('Hello $name, nice to meet you.');
print('1 + 1 = ${1 + 1}');
```

If you need to display the price in dollars, then what would you do? Yup, the *backslash* will tell Dart which $ sign as *interpolation* or as currency. Apart from that, you can also use the following methods:

```dart
//add 'r' in front of string
print(r'He just bought $1,000.00 computer');

//is equal to this
print('He just bought \$1,000.00 computer');
```

The '**r**' before the String will tell Dart to treat the *String* as *raw*, which means it will ignore *interpolation*.

In addition, we can also add a *Unicode* to a *String*. In Unicode Darts these are known as **runes**. Unicode defines a unique numeric value for each letter, number, and symbol used in all of the world's writing systems. A common way of expressing unicode is `\uXXXX`, where **XXXX** is a 4-digit hexadecimal value. For example the heart character (♥) is `\u2665`.

```dart
print('Hi \u2665');
 
/*
  output : Hi ♥
*/
```

&emsp;
## 07. Booleans
After numbers and text, there is one more main data type that is important to learn, namely the boolean. The name boolean is taken from the name of an English mathematician named **George Boole**. He is best known for the creation of boolean algebra, a branch of algebra in which the value of a variable is always true or false.

Booleans in Darts are declared with the keyword `bool`. According to the explanation above, a boolean variable can only store two values, namely `true` and `false`.

```dart
bool alwaysTrue = true;
var alwaysFalse = false;
var notTrue = !true;
bool notFalse = !false;
```

Sign! above is called the operator "**not**" or "**bang**". This operator serves to *specify a boolean value*, simply *reversing a boolean value*. For example,`!true` is the same as false.

We will use boolean a lot in application development for comparison operations as well as application conditioning.

```dart
if(true) {
  print("It's true");
} else {
  print("It's False");
 }
```

&emsp;
## 08. Operators
The term operator is borrowed from mathematics in a slightly different sense. On Dart the operator instructs the computer to perform the operation. In fact, we have applied some examples of operators in the previous material. For example the *assignment operator* (=) that we use to initialize variable values. like this :`var number = 4;`

### Arithmetic Operator
Other examples of operators you have seen are arithmetic operators used for operations such as addition or multiplication. Take a look at the following code examples:

```dart
var firstNumber = 4;
var secondNumber = 13;
var sum = firstNumber + secondNumber;
print(sum);
 
/*
Output : 17
*/
```

Dart supports the following common arithmetic operators:

|Operator   |Description    |
|-----------|---------------|
| +         |Sum            |
| -         |Subtraction    |
| *         |Multiplication |
| /         |Distribution   |
| ~/        |Return int     |
| %         |Modulo         |

```dart
print(5 + 2);   // int add = 7
print(5 - 2);   // int subtract = 3
print(5 * 2);   // int multiply = 10
print(5 / 2);   // double divide = 2.5
print(5 ~/ 2);  // int intDivide = 2
print(5 % 2);   // int modulo = 1
```

Arithmetic operators in programming have the same rules as mathematics, where multiplication and division take precedence before addition or subtraction.

```dart
print(2 + 4 * 2); // output: 10
```

If you want to perform the addition operation first, use *parentheses*.

```dart
print((1 + 3) * (4 - 2)); // output: 8
```
In addition Dart supports *increment* and *decrement*. Examples are as follows:

```dart
var a = 0, b = 5;
a++;
b--;
print(a); // output = 1
print(b); // output = 4
```

Expression `a++` above can be interpreted as `a = a + 1`. The computer will take the value from a then add 1 and then put it back into the variable `a`. Other forms of *increments* are as follows:

```dart
var c = 0;
c += 5;    // c = c + 5 or c = 0 + 5
print(c);  // output 5
```

This operator can also be used with other arithmetic operators such as multiplication and division.

```dart
var d = 2;
d *= 3;   // d = d * 3 or d = 2 * 3
print(d); // output = 6
```

### Comparison Operators
Dart also supports comparison operations to compare values ​​that are used as operands. The following is an example of a comparison operator on Dart:

|Operator |Description    |
|---------|---------------|
| ==      |Equal to       |
| !=      |Not equal to   |
| >       |More than      |
| <       |Less than      |
| >=      |More than equal|
| <=      |Less than equal|

This comparison operator will return the value in *boolean* form.

```dart
if (2 <= 3) {
  print('Yes, 2 is less than equal to 3');
} else {
  print("You're wrong");
}
 
/*
Output: Yes, 2 is less than equal to 3
 */
```

### Logic Operator
We can also combine *boolean* expressions or invert them with logical operators. These operators include:

|Operator |Description  |
|---------|-------------|
| \| \|   |OR           |
| &&      |AND          |
| !       |NOT          |

We have already discussed the *NOT* or *bang* operator in *boolean* material. Meanwhile, the OR or AND operator is used to test the logic of some boolean values. The AND operator will return *true* if all of its operands are *true*, while OR if only one of the operands is *true* then the operator will return *true*. An example is the following code:

```dart
if (2 < 3 && 2 + 4 == 5) {
  print('To print this, all condition must true');
} else {
  print('2 less than 3, but 2 + 4 not equal to 5, then this will show');
}
 
if (false || true || false) {
  print('1 value is true');
} else {
  print('if all is false, then this will show');
}
  
/*
Output:
  2 less than 3, but 2 + 4 not equal to 5, then this will displayed
  1 value is true
*/
```

&emsp;
## 09. Exceptions
An application that is already running may experience errors and crashes. This error **condition when the application is running (*runtime*)** is known as an exception. When an exception occurs the application will be terminated and the program after it will not be executed.

One example of an *exception* that may occur is in the calculator application. Where according to mathematical principles we cannot divide another number by zero (0).

```dart
var a = 7;
var b = 0;
print(a ~/ b);
```

Try running the code above. You will get an error like the following:

```bash
> Unhandled exception:
> IntegerDivisionByZeroException
> #0 int.~/ (dart:core-patch/integers.dart:24:7)
> #1 main (file:///path/Learn%20Dart/bin/main.dart:24:11)
> #2 _startIsolate.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:305:32)
>#3 _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:174:12)
```

As *developers*, of course, it's our job to make sure the application continues to run regardless of the conditions, including handling when an *exception* occurs. Then how? To handle exceptions, let's use `try` and `catch`. Move code that has the potential to raise an exception into the try block.

```dart
try {
  var a = 7;
  var b = 0;
  print(a ~/ b);
}
```

The code above is still incomplete because in a `try` block there is code that is assumed to be an exception that needs to be handled. In the previous error it was noted that the exception that occurred was an `IntegerDivisionByZeroException` . So we can use the `on` keyword to handle when the exception occurs.

```dart
try {
  var a = 7;
  var b = 0;
  print(a ~/ b);
} on Exception {
  print('Can not divide by zero.');
}
```

Well, we have succeeded in making our program safe from *crash* by making use of Exception. The code block `on Exception` above is a general use of exceptions. But what about other exceptions that we don't know about? In Dart itself there are several exceptions such as `IOException`, `FormatException`, etc. To handle exceptions that are not specifically known, we can use the `catch` keyword after the `try` block.

```dart
try {
  var a = 7;
  var b = 0;
  print(a ~/ b);
} catch (e) {
  print('Exception happened: $e');
}
```

The *catch* code takes one parameter which is an *exception* object. We can print the *exception* to the screen to show what *exception* occurred. The output of the code above is:

` Exception happened: IntegerDivisionByZeroException `

Apart from that, we can also add one more parameter inside the `catch` which is a *stack trace* object. From this *stack trace* we can see the details of the *exception* and in which line the exception occurred.

```dart
try {
  var a = 7;
  var b = 0;
  print(a ~/ b);
} catch(e, s) {
  print('Exception happened: $e');
  print('Stack trace: $s');
}
 
/*
Output :
Exception happened: IntegerDivisionByZeroException
Stack trace: #0      int.~/ (dart:core-patch/integers.dart:24:7)
#1      main (file:///path/dart/Learn%20Dart/bin/main.dart:25:13)
#2      _startIsolate.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:305:32)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:174:12)
 */
```

The `catch` block can be combined with `on`. `Catch` will catch if no *exception* satisfies the attached `on` block.

### Finally
In addition to *try*, *on*, and *catch*, there is one more block in the *exception handling* mechanism, namely **finally**. The finally block will still execute regardless of the outcome of the `try-catch` block.

```dart
try {
  var a = 7;
  var b = 0;
  print(a ~/ b);
} catch(e, s) {
  print('Exception happened: $e');
  print('Stack trace: $s');
} finally {
  print('This line still executed');
}
```

&emsp;
## 10. Make Temperature Conversion App
Say you are invited to attend a developer conference in America, but you are confused because it turns out that America uses the Fahrenheit temperature standard. Of course if you had an app that could convert the temperature from Fahrenheit to Celsius, it would be very useful, wouldn't it?

Before entering into making applications, of course we must know the temperature conversion formula first. The flow of our temperature conversion application will be as follows:

1. Receive fahrenheit temperature input from user. 
2. Do the conversion according to the formula. 
3. Displays conversion results.

This is what it looks like if the process is poured into a flowchart:

<p align="center" width="100%">
  <img src="https://github.com/DVCone/flutter_course/blob/main/assets/03_b.jpeg" alt="alternate text">
</p>

1. First, create a new project in your IDE and give it a name, for example `Temperature Conversion`.
2. Next, we need to receive input from users and don't forget to display what information needs to be input. Delete all the code in the `main.dart` file then add the following code:

```dart
import 'dart:io';
 
void main() {
  // User Input
  stdout.write('Insert Temperature in Fahrenheit: ');
  var fahrenheit = num.parse(stdin.readLineSync()!);
  // Perform the conversion by entering the temperature conversion formula.
  var celsius = (fahrenheit - 32) * 5 / 9;
  // Finally display your conversion results to the console.
  print('$fahrenheit Fahrenheit Degrees = $celsius celsius Degrees');
}
```
3. Run and test if your application is running properly.

### Challenge
As a challenge, make your app able to support other temperature conversions like Reaumur, Kelvin, etc.

```dart
import 'dart:io';
 
void main() {
  // User Input
  stdout.write('Insert Temperature in Fahrenheit: ');
  var fahrenheit = num.parse(stdin.readLineSync()!);
  // fahrenheit to celsius
  var celsius = (fahrenheit - 32) * 5 / 9;
  // Finally display your conversion results to the console.
  print('$fahrenheit Fahrenheit Degrees = $celsius celsius Degrees');
  // fahrenheit to kelvin
  var kelvin = celsius +  273;
  print('$fahrenheit Fahrenheit Degrees = $kelvin kelvin Degrees');
  // fahrenheit to reaumur
  var reaumur = (fahrenheit - 32) * 0.44444;
  print('$fahrenheit Fahrenheit Degrees = $reaumur reaumur Degrees');
  // fahrenheit to rankine
  var rankine = fahrenheit + 459.67;
  print('$fahrenheit Fahrenheit Degrees = $rankine rankine Degrees');
}
```

&emsp;
## 11. Functions
*Functions* in Dart are used to generate output based on a given input, as well as reusable code blocks or procedures. Consciously or not, we actually have implemented several functions in our code. All Dart programs start from the `main()` function. `main()` is an example of the main function we always use. In addition, `print()` is also a function.

`print('Hello Dart!');`

The `print()` function will take a *String* value or other object and output it to the console. To print something to the console actually requires some *lower-level* instructions, but we are greatly helped by the `print()` function and can use it repeatedly.

To declare a function, the method is the same as writing the `main()` function, that is, by specifying the type of *return value* and then the name of the function and its input parameters.

```dart
returnType functionName(type param1, type param2, ...) {
  return result;
}
```
Every Dart function always returns a value. However, there is one special data type that we can see in the main function, which is the return type **void**. The keyword `void` means that the function does not return an output or return value. Usually a function like this is used for a collection of instructions or procedures that are repeated and often used.

After the function is created, we can then call it in the `main()` function or in any other part of the program you want.

```dart
void main() {
  greet(); // output : Hello!
}
 
void greet() {
  print('Hello!');
}
```

In the simple example above, the `greet()` function doesn't save a lot of the code you wrote. However, if you have 30 *greet* instructions and it turns out that the latest version of your app requires changing the text displayed, you just need to change one line of code instead of 30 different lines of code. Also, if you have code that is quite long it would be better if it was put into a function to make it easier to read.

### Function Parameters
In some cases the function may require input data to be processed. We know this input data as **parameters**. To add parameters to a function, we can put them in parentheses. A function can accept zero, one, or more parameters.

An example of using parameters in functions that we have seen is the `print()` function.

`print('Hello Dart!');`

The following is an example function with two parameters:

```dart
void main() {
  greet('John', 2015);  // output : Halo John! This year you are 5 years old
}
 
void greet(String name, bornYear) {
  var age = 2020 - bornYear;
  print('Halo $name! This year you are $age years old');
}
```

A function can also produce output or return a value. Functions that return a value are specified with a *return type* definition other than void and have the `return` keyword. Examples are as follows:

```dart
void main() {
  var firstNumber = 7;
  var secondNumber = 10;
  print('Average value from $firstNumber & $secondNumber is ${average(firstNumber, secondNumber)}');
}
 
double average(num num1, num num2) {
  return (num1 + num2) / 2;
}
```

If a function has only one line of code or instructions in it, it can be abbreviated with the `=>` annotation. This is also known as `arrow syntax`.

```dart
double average(num num1, num num2) => (num1 + num2) / 2;
void greeting() => print('Hello');
```

### Optional Parameters
Let's say you have this function : `void greetNewUser(String name, int age, bool isVerified)`

the only way to be able to call the above function is in the following way: `greetNewUser('John', 20, true);`

However, Dart supports **optional parameters**, where we don't have to fill in the parameters requested by the function. To be able to make parameters optional, we need to put them in square brackets like the following example: `void greetNewUser([String name, int age, bool isVerified])`

This method is called the **positional optional parameters**. With optional parameters as above we can call the function as follows:

```dart
greetNewUser('John', 20, true);
greetNewUser('John', 20);
greetNewUser('John');
greetNewUser();
```

Any parameter that is not entered will have a **null value**. However, since version 2.12, Dart has a **null safety** feature where a variable cannot by default have a null value. The solution, we can add a question mark (?) after the data type so that it can store a null value or provide a default parameter value. This value will be used if we do not enter the parameter.

```dart
void greetNewUser([String? name, int? age, bool isVerified = false]) {}
```
Note: We will discuss more deeply about the null safety feature in the "Null Safety" material. 

In this way, the order of the parameters still needs to be considered so if we only want to fill the last parameter, we need to fill the previous parameter with null. `greetNewUser(null, null, true);`

To solve the above problem we can take advantage of **named optional parameters**. In this option we use curly braces on the parameter. with this way you can enter parameters regardless of the order of the parameters by specifying the parameter names.

```dart
void greetNewUser({String name, int age, bool isVerified})

greetNewUser(name: 'John', age: 20, isVerified: true);
greetNewUser(name: 'John', age: 20);
greetNewUser(age: 20);
greetNewUser(isVerified: true);
```

Note that this parameter is optional and will be null by default. To meet null safety, you can use the same method as before, or mark the required parameters with the **required** keyword.

```dart
void greetNewUser({required String name, required int age, bool isVerified = false}) {}
```

&emsp;
## 12. Variable Scope
Once you've separated your code into separate blocks or functions, you need to be aware that this will affect how a variable is used. Each variable has its own scope or scope. A variable is considered one scope as long as it is in the same block of curly braces. This scope determines which parts of the code can read and use the variable.

Look to the following code:

```dart
void main() {
  var isAvailableForDiscount = true;
  var price = 300000;
  var discount = 0;
  if (isAvailableForDiscount) {
    discount = 50000;
  }
  print('You need to pay: ${price - discount}');
}
```

In the code above the `discount` variable can still be accessed from inside the `if` code because it is still in the same scope of the `main()` function. What if you wanted to split the code above into two functions to calculate the discount?

```dart
void main() {
  var price = 300000;
  var discount = checkDiscount(price);
  print('You need to pay: ${price - discount}');
}
 
num checkDiscount(num price) {
  num discount = 0;
  if (price >= 100000) {
    discount = 10 / 100 * price;
  }
 
  return discount;
}
```

The `discount` variable is declared in the `checkDiscount()` function so it has scope for that function and causes an error in the `main()` function. So to solve this we still need to create variables in both functions. 

Apart from being in the scope of a function, a variable can also be a global variable, i.e. a variable declared outside any block of code. This variable can be accessed anywhere as long as it is in the same file.

```dart
var price = 300000;
 
void main() {
  var discount = checkDiscount(price);
  print('You need to pay: ${price - discount}');
}
 
num checkDiscount(num price) {
  num discount = 0;
  if (price >= 100000) {
    discount = 10 / 100 * price;
  }
 
  return discount;
}
```

Variables can also have a scope that is as specific as possible down to the level of control flow.

```dart
num checkDiscount(num price) {
  num discount = 0;
  if (!discountApplied) { // Error
    if (price >= 100000) {
      discount = 10 / 100 * price;
      var discountApplied = true;
    }
  }
 
  return discount;
}
```

&emsp;
## 13. Constant & Final
Sometimes we need to store a value that will never change while the program is running. Variables have helped us to store values ​​and can be accessed with descriptive names. `Constants` are something new that we are going to learn and are useful for storing values ​​that will not change as long as the program is running.

According to the definition above, we can define a constant value in our program. One of the easiest examples we can take is the value of pi = 3.14. To define a constant variable, use the `const` keyword. ex: `const pi = 3.14;`

Dart's type inference will automatically detect the data type of `const pi` above as `double`, but you can specify the data type explicitly: `const num pi = 3.14;`. So in a circle area calculator application, your code would be as follows:

```dart
const num pi = 3.14;
 
void main() {
  var radius = 7;
  print('The area of ​​the circle with $radius = ${calculateCircleArea(radius)} radius');
}
 
num calculateCircleArea(num radius) => pi * radius * radius;
```

Apart from `const`, another option to avoid changing the value of a variable after initialization is `final`. What is the difference between `final` and `const`? 

Variables declared as `const` are *compile-time constants*, meaning they must be known before the program is run. While `final`, the value can still be initialized at *runtime* or when the application is running. For example the following code:

```dart
final firstName = stdin.readLineSync();
final lastName = stdin.readLineSync();
 
//  lastName = 'Dart'; can't change the value
 
print('Hello $firstName $lastName');
```

We can still accept input and store it in the `firstName` and `lastName` variables, but the value of these variables cannot be changed after initialization. 

Variables whose values ​​cannot be changed are known as **immutable variables**. This *mutability* allows us to avoid unexpected bugs due to value changes. Therefore, if you are sure that your variable has a fixed value, use `const` or `final`.

So when should we use `const` and when is `final`? Whenever possible, always use `const` because *compile-time constants* perform better and use less memory. If it's not possible to use `const`, use `final` to protect the variable from changing.

&emsp;
## 14. Null Safety
Since version 2.12, Dart brings the Null Safety feature. What is null safety and why do we need it? Before discussing null safety further, let's review about variables and data types again. As we discussed earlier, variables are used to store values. String variables are used to store text, num is used to store numbers, etc.

```dart
String name = 'John Doe';
int age = 23;
```

However, in reality a variable can also have no value. The value "none" in this Dart is known as the null value. A null value can occur because we have not initialized the value or did explicitly specify a null value in the variable. `String favoriteFood = null;`.

Then, why should we care about this null value? A null value can cause a program to experience an error known as a *Null Pointer Exception (NPE)*. In fact, the developer who first introduced the NPE called it **“the billion dollar mistake”**.

Imagine a friend who wants to treat you to your favorite food, but because you don't have a favorite food, then he will be confused. Likewise with computers. If the value of the variable is null or "none", then the computer will also be confused so that it can cause the program to *crash*.

However, null values ​​are not completely bad. There will still be certain cases where we need a null value. An example is the `favoriteFood` variable above because not everyone has a favorite food. Null safety is the answer to the above case. 

To use the null safety feature, we need to use Dart version 2.12. You can determine which version of Dart to use by modifying the **pubspec.yaml** file contained in the project. Make sure the minimum version of the sdk used is version 2.12.0.

```dart
environment:
  sdk: '>=2.12.0 <3.0.0
```

With null safety, by default a variable cannot have a null value, unless we declare it explicitly.

```dart
int age = null;               // Compile error
String? favoriteFood = null; 
```

The question mark (`?`) above indicates that the `favoriteFood` variable may have a null value (*nullable*). While the `age` variable must have a numeric value and cannot be null (*non-nullable*).

The code above will not run because it failed in the compilation process. Therefore, null safety is very useful for making code more secure because processes involving null values ​​can be restricted and found earlier. 

If we have a function with non-nullable parameters, the nullable argument will be detected as an error.

```dart
void main() {
  String name = 'John Doe';
  int age = 23;
  String? favoriteFood = null;
 
  buyAMeal(favoriteFood);       // Compile error
}
 
void buyAMeal(String favoriteFood) {
  print('bought a $favoriteFood');
}
```

To access or handle null variables as above, there are several ways we can do. First, change the parameters to accept null values ​​and then check for null values.

```dart
void buyAMeal(String? favoriteFood) {
  if (favoriteFood == null) {
    print('Bought Fried Chicken');
  } else {
    print('Bought $favoriteFood');
  }
}
```

The second way we can do this is to use the *bang operator* (`!`). With this operator we notify the compiler and provide a guarantee that the variable will not be null. However, when a variable turns out to be null, it's still possible to crash. So, use this bang operator only when you are 100% sure that the variable will not be null.

```dart
void main() {
  String name = 'John Doe';
  int age = 23;
  String? favoriteFood = 'Ramen Noodle';
 
  buyAMeal(favoriteFood!);
}
 
void buyAMeal(String favoriteFood) {
  print('Bought $favoriteFood');
}
```

&emsp;
## 15. Summary
Happy! You have learned the fundamentals of programming. Before you move on to the next sub-module, here are some summaries of the sub-modules that have been studied:

1. Comments to write comments or explanations of the code written.
2. There are three types of comments available on Dart:
    1. Single-line comments or one-line comments starting with // and ending at the end of the line. 
    2. Multi-line comments where we can write several lines of comments starting with /* and ending with */.
    3. A documentation comment is a single-line and multi-line combination that begins with /// or /** and ends with /// or **/.
3. Instructions or code commands that begin with a comment will be skipped during the compilation process, so they will not affect the flow of the program being written. 
4. Variables are used to store values. We can define variables implicitly using the var keyword.
5. Dart supports many data types that can be used. The types of data types supported by Dart include:
    1. `int` is a data type that can hold integers. 
    2. `double`, a data type that can accommodate decimal numbers. 
    3. `num`, a data type that can accommodate integers `int` and decimal numbers `double`. 
    4. `bool`, a data type that has only two values, true and false. 
    5. `String`, a data type that can store text consisting of 0 or more characters.
    6. `Collection`, a data type that can store multiple objects in one variable. 
    7. `dynamic`, a data type that can store any data type.
6. We can combine boolean statements or reverse them with logical operators. There are 3 logical operators that can be used, including:
    1. The OR operator `||`, the operator that will return true if one of the expressions evaluates to true. 
    2. AND operator `&&`, operator that will return true if all expressions evaluate to true. 
    3. The NOT `!` operator, the operator that negates the given expression.
7. Functions are used as mini programs or code blocks that can produce output from certain inputs. 
8. Constant variables (const and final) are useful for storing values ​​that will not change while the program is running. 
9. Variables with the const keyword are compile-time constants, meaning they must be known before the program is run.
10. Variables with the final keyword have the property that their values ​​can still be initialized while the application is running. 
11. Dart's null safety feature helps limit the use of null values ​​which are prone to crashing the application if not handled properly.

In this module you have also created a simple application to convert temperature. Are you ready to build even more complex applications? If there's still a concept you don't understand, feel free to reread the module. You can also make questions on the discussion forum. In the next module, we will discuss how to adjust the program flow to the way we expect it.

&emsp;
## 16. Quiz

```dart
void main () {
  var string = 'Dart';
  var number = 2.7;
  print(string + number);
}
```

1. what is the output of the code above?
<br> =

```dart
void main() {
  print(product(5, 7));
}

num product(int firstNumber, double secondNumber) {
  return firstNumber * secondNumber;
}
```

2. what's wrong with the code above?
<br> =
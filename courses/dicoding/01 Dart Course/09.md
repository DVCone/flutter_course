# Dart Futures

## 01. Introduction to Dart Futures
So far we have written code synchronously . Furthermore, in this module we will study code that works asynchronously . Before discussing asynchronous more deeply, we will first discuss what is the difference between synchronous and asynchronous .

### Synchronous vs Asynchronous
In a synchronous program , the program code is executed sequentially from top to bottom. This means that if we write two lines of code, the second line of code cannot be executed before the first line of code is executed. We can imagine when we are in the cashier queue. We will not be served before all the queues in front of us have been served, nor will the people behind us have to wait their turn.

In an asynchronous program , if we write two lines of code, we can make the second line of code execute without having to wait for the code on the first line to finish executing. In the real world, we can imagine ordering coffee through a waiter, where while waiting for our order to arrive, we can do other activities such as opening a laptop or writing.

<p align="center" width="100%">
  <img src="https://github.com/DVCone/flutter_course/blob/main/assets/09_a.jpeg" alt="alternate text">
</p>

An asynchronous program allows one operation to run while waiting for another operation to complete. We generally use asynchronous operations for large and time-consuming operations, such as retrieving data from the internet or an API, saving data to a database , and reading data from a file.

&emsp;
## 02. What is Future
To program asynchronously with Dart, we use **Future**. Future is an object that represents a potential value or error that will be available at some time in the future. You can think of futures as a package box. When you receive the package, there will be three conditions that may occur, including the package is still closed (**uncompleted**), the package is opened and contains the goods as ordered (**completed with data**), and the package is opened but an error occurs or does not match (**completed with error**) . The recipient of the future can define callbacks that will handle the value or error.

```dart
void main() {
  print('Creating the future');
  print('main() done');
}
```

Surely you already know the order of the programs and what will be displayed on the console. Then what if we move the first `print` command into the future object .

```dart
void main(){ 
  final myFuture = Future(() {
    print('Creating the future');
    return 12;
  });
  print('main() done');
}

/* Output :
> main() done
> Creating the future
*/
```

If the above code is executed, all the `main` functions will be executed before the functions inside `Future()`. This is because future is still incomplete.

So how do we create and utilize this future ?

### Uncompleted
Let's create a function that returns a Future value .

```dart
Future<String> getOrder() {
  return Future.delayed(Duration(seconds: 3), () {
    return 'Coffee Bean';
  });
}
```

In `Future` we can add `delayed` method to delay execution of code inside `Future` . Where the first parameter contains the duration of the delay and the second parameter is the block of code or function to be executed. In this case we use delayed to delay execution time as if we were retrieving data from the internet. Since the value returned in `Future` is a `String` , we can explicitly specify the generic parameter type `Future<String>`.

### Completed with Data
Then after `Future` is executed, we need a handler to handle the status completed with data . To do this, use the `.then()` method of the `Future` object .

```dart
void main() {
  getOrder().then((value) {
    print('Your ordered: $value');
  });
  print('Getting your order...');

/* Output :
> Getting your order...
> You ordered : Coffee Bean // Appears after 3 seconds   
*/
}
```

The `getOrder()` function will execute asynchronously until after 3 seconds the `Future` code will execute and return a value.

What if the `Future` object returns the condition “ completed with error ?” How to handle it?

### Completed with error
We can add a `.catchError()` method after `then` . So when an error or exception occurs in `Future` , this code block will be executed. Let's slightly modify the code above to support the completed with error scenario .

```dart
void main() {
  getOrder().then((value) {
    print('You ordered: $value');
  })
  .catchError((error) {
    print('Sorry. $error');
  });
  print('Getting your order...');
}
 
Future<String> getOrder() {
  return Future.delayed(Duration(seconds: 3), () {
    var isStockAvailable = false;
    if (isStockAvailable) {
      return 'Coffee Bean';
    } else {
      throw 'Our stock is not enough.';
    }
  });
}
```

What do you think will show on the console? Try running the application to prove it.

At this point, you should be familiar with the three states in Future and how to write code to handle them. As in the `main()` function there are three blocks of code that represent the Future state :

1. The `getOrder()` function contains an **uncompleted** Future .
2. The `then()` method handles the **completed with data** condition .
3. The `catchError ()` method handles the **completed with error** condition .

There is one more method that we can use which is `whenComplete()` . This method will be executed when a `Future` function finishes executing, regardless of whether it returns a value or an error. It's like the `finally` block on *try-catch-finally* .

```dart
void main() {
  getOrder().then((value) {
    print('You ordered: $value');
  })
  .catchError((error) {
    print('Sorry. $error');
  })
  .whenComplete(() {
    print('Thank you');
  });
  print('Getting your order...');
}
```
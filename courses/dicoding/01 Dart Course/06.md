# Object Oriented Programming (OOP)

## Paradigm of OOP
In the first module we already know that Dart is a language that supports object-oriented programming. OOP is a programming paradigm that is widely used today for developing applications.

The OOP paradigm is based on the concept of objects that have attributes and can perform certain operations or procedures. With OOP, we can easily visualize objects that exist in the real world into computer programs. For example, imagine a cat as an object. This cat object has characteristics such as coat color, cat age, and weight. These characteristics are called *attributes* or *properties*. In addition, cats can also do several things such as eating, sleeping, and playing. The behavior of this cat object is a *method*.

There are 4 (four) pillars in object-oriented programming, including: *encapsulation*, *abstraction*, *inheritance*, and *polymorphism*.

### Encapsulation
Encapsulation is a condition where the state or condition in the `class`, is wrapped and is private. This means that other objects cannot access or change the value of the `property` directly. In the example of the cat case, we cannot directly change the weight of the cat, but we can add it through the function or feeding `method`.

### Abstraction
Abstraction is arguably a natural application of encapsulation. Abstraction means that an object only performs its operations in a *high-level* manner. For example, we know enough about how a cat eats, but we don't need to know what the biological metabolism in a cat's body is that makes her gain weight.

### Inheritance
Some objects can have some characteristics or behavior in common, but they are not the same object. This is where inheritance or inheritance comes into play. Cats have traits and behaviors that are common with other animals, such as having a color, weight, etc. Therefore, the cat as a child object (*subclass*) inherits all the properties and behaviors of its parent object (*superclass*). Likewise, fish objects also inherit the same characteristics and behavior, but fish can swim while cats cannot.

### Polymorphism
Polymorphism in Greek means "many forms." Simply put, objects can have different forms or implementations in the same method. All animals breathe, but of course cats and fish have a different way of breathing. The difference in shape or way of breathing is an example of polymorphism.

&emsp;
## 02. Class
One of the main features of OOP is features like **class**. *Class is a blueprint* for creating objects. In this class we define the properties (*attributes*) and *behavior* of the object to be created. For example, the Animal class has attributes such as name, weight, and age, etc. Then the behavior is eating, sleeping, etc.

Each class has *attributes* and *behavior*. In Dart we define *attributes* with variables, while *behavior* is often represented as a *function*.

|attribute        |behavior   |
|-----------------|-----------|
|String name      |eat()      |
|int age          |sleep()    |
|double weight    |poop()     |

To define a class in Dart, just use the keyword `class` followed by the name of the class to be created.

```dart
class Animal {
}
```

Then we can add variables and functions to the class.

```dart
//Animal Class
class Animal {
  //Attribute
  String name;
  int age;
  double weight;
  
  //Object Class
  Animal(this.name, this.age, this.weight);
  
  //Behavior Function
  void eat() {
    print('$name is eating.');
    weight = weight + 0.2;
  }
  
  void sleep() {
    print('$name is sleeping.');
  }

  void poop() {
    print('$name is pooping.');
    weight = weight - 0.1;
  }
}
```

Then to create an object of a class, use the following syntax: `var nameOfObject = NameOfClass(property1, property2);`

An object is like a variable, meaning we can use `var` to initialize an object. Objects stored in this variable are also known as *instances* or *instances of a class*. This *instance* stores the *reference* or memory address of the object. The process of creating an instance variable as above is called *instantiation*.

`var garfieldCat = Animal('Garfield', 2, 4.2);`

We use the class name followed by parentheses. Inside these brackets we can pass parameters to initialize the values ​​in the object. This parenthesis is a *constructor* that we will study in the next material. After the object is created we can run a function or display the value of the *property* in it.

```dart
void main() {
  var garfieldCat = Animal('Garfield', 2, 4.2);
  garfieldCat.eat();
  garfieldCat.poop();
  print(garfieldCat.weight);
}

/* Output :
> Gray is eating.
> Gray is pooping.
> 4.300000000000001
*/
```

&emsp;
## 03. Properties & Methods
We have studied variables for storing values ​​and *functions* for writing reusable instruction sets. Within a class, variables and functions are known as **properties** and **methods**.

As mentioned in the *Class* material, *property* represent the attributes of an object while *methods* describe the behavior of the object. Just like variables, we declare properties in classes by specifying their data type or explicitly initializing their values.

```dart
class Animal {
  String _name = '';
  int _age = 0;
  double _weight = 0;
}
```

OOP has the concept of encapsulation where we can hide information inside an object so that the state or data in the object cannot be changed or even seen. Generally, programming languages ​​have a *visibility modifier* to determine who can access a property or method. However, Dart does not have a *keyword visibility modifier* such as private or public. How to handle it?

Make the class a library and call it with the keyword `import`. To create a class as a library you simply create a new file, so you will have 2 files:

> [Practice on `test/dicoding_test/06_main.dart.dart`]
> [Practice on `test/dicoding_test/06_animal.dart`]

A private property means that it can only be accessed in the same file or library. We will need this private property when we don't want the object to be changed from the outside. Since Dart has no *private modifier*, instead we need to add an underscore (`_`) before the *property* name.

```dart
String _name = '';
int _age = 0;
double _weight = 0;
```

After adding an *underscore* to the variable name, you will get an error in the `main.dart` file when accessing the `weight` property. What's the article? Now `weight` is *private* and cannot be accessed from outside the file. As a workaround, you can add setters and getters to get the values ​​and change them from outside the file. **If using IntelliJ IDEA** you can use the shortcut **Alt + Insert** then **select Getter and Setter**.

```dart
// Setter
set name(String value) {
  _name = value;
}
 
// Getter
double get weight => _weight;
```

In addition to the setter, you can also change the value with the property of the method call. In the `animal class` example, of course, we cannot directly change the weight value, but we can increase and change the value through the process of eating or defecating (poop).

```dart
void eat() {
  print('$_name is eating.');
  _weight = _weight + 0.2;
}
 
void poop() {
  print('$_name is pooping.');
  _weight = _weight - 0.1;
}
```

&emsp;
## 04. Constructor
When an object is created, all properties of that class must have a value. We can directly initialize certain properties or initialize them via **constructor**. A constructor is a special function of a class that is used to create objects.

As the name implies, constructors are used to construct new objects. So why is the constructor called a special function? How is it different from other functions in the class? Some of the differences between constructors and regular functions are:

1. Constructor has the same name as the class name. 
2. Constructor has no return value (return type). 
3. The constructor will be automatically called when an object is created.
4. If we don't define a constructor, a default constructor with no arguments is created.

In the previous material, you indirectly learned to create a constructor that accepts multiple arguments. However, by default a class constructor does not accept any arguments. For example, the Animal class would be like this:

```dart
class Animal {
  String name = '';
  int age = 0;
  double weight = 0;
}
```

To create a new object of the class, you do not need to pass any arguments. `var garfieldCat = Animal();`

Since we did not enter a value when creating the object, the default value of the property or variable will be used. You need to be careful not to assign a value to the property, as this will make the property *null* and could cause an error. To assign a value to a property, please access an existing property in a class.

```dart
var garfieldCat = Animal();
garfieldCat.name = 'Gray';
garfieldCat.age = 2;
garfieldCat.weight = 4.2;
```

By creating a constructor, we can not only initialize values ​​but also execute certain instructions when the object is created.

```dart
Animal(String name, int age, double weight) {
  this.name = name;
  this.age = age;
  this.weight = weight;
  // other instructions
}
```

The `this` keyword above refers to an object in that class. This keyword is generally used to avoid ambiguity between attributes of a class and parameters that have the same name.

If the constructor is only used to initialize property values, then the constructor code can be summarized as follows:

```dart
Animal(this.name, this.age, this.weight);
```

### Named Constructor
In some cases we may need several constructors for different scenarios. In this situation we can use **named constructors**. By using named constructors, we can create multiple constructors in the same class. Each constructor will have a unique name.

```dart
// Formula
class_name.constructor_name (arguments){
  // Statements
}

// Example from 06_animal.dart
Class Animal {
  ...
  Animal.Name(this._name);
  Animal.Age(this._age);
  Animal.Weight(this._weight);
  ...
}
```